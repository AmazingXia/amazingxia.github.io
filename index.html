<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>魔方</title>
  <script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/cube.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/solve.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html,
    body {
      overflow: hidden;
      height: 100%;
      touch-action: none;
      background: rgb(134, 122, 209);
      position: relative;
    }

    ul {}

    li {
      list-style: none;
    }

    /* { front: { backGround: rgba(0,255,255,.5) },
     back: { backGround: rgba(153,204,255,.5) },
     left: { backGround: rgba(128,0,128,.5) },
     right: { backGround: rgba(255,0,255,.5) },
     top: { backGround: rgba(255,153,204,.5) },
     bottom: { backGround: rgba(0,204,255,.5) },
      inner: { backGround: rgba(100,100,100,.5) } } */
    .gray {

      background-color: rgb(90, 85, 94);
      /* backGround: rgba(0,255,255,.8); */
    }

    .blue {
      background-color: rgb(62, 132, 224);
      /* backGround: rgba(255,0,255,.8); */
    }

    .red {

      background-color: #F7685B;
      /* backGround: rgba(153,204,255,.8); */
    }

    .pink {
      background-color: rgb(245, 142, 202);
      /* backGround: rgba(255, 153, 204, .8); */
    }

    .green {
      background-color: #67C23A;
      /* backGround: rgba(0,204,255,.8); */
    }

    .yellow {
      background-color: #FFB946;
      /* backGround: rgba(100,100,100,.8); */
    }

    .base {
      position: relative;
      height: 242px;
      width: 242px;
      margin: 0 auto;
      margin-top: 180px;
      transform-style: preserve-3d;
      user-select: none;
    }

    .base-public {
      position: absolute;
      top: 0;
      left: 0;
      width: 240px;
      height: 240px;
      box-sizing: border-box;
      transform-style: preserve-3d;
      transform-origin: 120px 120px;
    }

    .base-base {
      /* background-color: #F7685B; */
      transform: rotate3d(1, 0, 0, 90deg);
    }

    .base-side {
      /* background-color: #67C23A; */
      transform: rotate3d(0, 1, 0, -90deg) translateY(550px);
      transform: rotate3d(0, 1, 0, -90deg);
    }

    .base-front {
      /* background-color: #FFB946; */
      /* transform: translateX(400px); */
    }

    .cube {
      position: absolute;
      top: 0;
      left: 0;
      width: 80px;
      height: 80px;
      box-sizing: border-box;
      transform-style: preserve-3d;
    }

    .public {
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
      left: 0;
      text-align: center;
      line-height: 80px;
      font-size: 24px;
      border: 4px solid #000000;
      border-radius: 6px;
      box-sizing: border-box;
      text-align: center;
      line-height: 80px;
      user-select: none;
    }



    .left {
      width: 240px;
      height: 240px;
      /* transform: translate3d(0px, 0px, 80px); */
      transform-style: preserve-3d;
      transform-origin: 50% 50%;
      transition: transform 0.2s linear;
      position: absolute;
      left: 0;
      top: 0;
      /* background-color: rgb(90, 85, 94); */
      /* background-color: rgb(62, 132, 224); */
      transform: translateZ(33.33%) rotateZ(0deg);
    }

    .center {
      width: 240px;
      height: 240px;
      transform: translate3d(0px, 0px, 0px);
      transform-style: preserve-3d;
      transform-origin: 50% 50%;
      transition: transform 0.2s linear;
      position: absolute;
      left: 0;
      top: 0;
      /* background-color: rgb(90, 85, 94); */
      transform: translateZ(0) rotateZ(0deg);
    }

    .right {
      width: 240px;
      height: 240px;
      transform-style: preserve-3d;
      transform-origin: 50% 50%;
      transition: transform 0.2s linear;
      position: absolute;
      left: 0;
      top: 0;
      /* background-color: #F7685B; */
      transform: translateZ(-33.33%) rotateZ(0deg);
    }



    /* .cube-first {
              transform: translate3d(0px, 0px, 120px);
          }
          .cube-second {
              transform: translate3d(0px, 0px, 40px);
          }
          .cube-third {
              transform: translate3d(0px, 0px, -40px);
          } */
    .cube-first-first,
    .cube-second-first,
    .cube-third-first {
      left: 0px;
      top: 0px;
    }

    .cube-first-second,
    .cube-second-second,
    .cube-third-second {
      left: 80px;
    }

    .cube-first-third,
    .cube-second-third,
    .cube-third-third {
      left: 160px;
    }

    .cube-first-forth,
    .cube-second-forth,
    .cube-third-forth {
      left: 0px;
      top: 80px;
    }

    .cube-first-five,
    .cube-second-five,
    .cube-third-five {
      left: 80px;
      top: 80px;
    }

    .cube-first-six,
    .cube-second-six,
    .cube-third-six {
      left: 160px;
      top: 80px;
    }

    .cube-first-seven,
    .cube-second-seven,
    .cube-third-seven {
      left: 0px;
      top: 160px;
    }

    .cube-first-eight,
    .cube-second-eight,
    .cube-third-eight {
      left: 80px;
      top: 160px;
    }

    .cube-first-nine,
    .cube-second-nine,
    .cube-third-nine {
      left: 160px;
      top: 160px;
    }

    .cube .public:nth-child(1) {
      transform-origin: 0px 40px;
      transform: translate3d(0px, 0px, 40px) rotate3d(0, 1, 0, 90deg);
    }

    .cube .public:nth-child(2) {
      transform-origin: 40px 40px;
      transform: rotate3d(1, 0, 0, 90deg) translate3d(0px, 0px, -40px);
    }

    .cube .public:nth-child(3) {
      transform-origin: 40px 0px;
      transform: rotate3d(0, 1, 0, 90deg) translate3d(0px, 0px, 40px);
    }

    .cube .public:nth-child(4) {
      transform-origin: 40px 40px;
      transform: rotate3d(1, 0, 0, 90deg) translate3d(0px, 0px, 40px);
    }

    .cube .public:nth-child(5) {
      transform: translate3d(0px, 0px, -40px);
    }

    .cube .public:nth-child(6) {
      transform: translate3d(0px, 0px, 40px);
    }

    .el-message {
      min-width: 70%;
      box-sizing: border-box;
      border: 1px solid #ebeef5;
      position: fixed;
      left: 50%;
      top: 20px;
      opacity: 0;
      transform: translateX(-50%) translateY(-40px);
      transition: opacity .3s, -webkit-transform .4s;
      transition: opacity .3s, transform .4s;
      transition: opacity .3s, transform .4s, -webkit-transform .4s;
      padding: 5px 15px 5px 15px;
      display: flex;
      align-items: center;
      border-radius: 4px;
      overflow: hidden;
      background-color: #f0f9eb;
      border-color: #e1f3d8;
    }

    .el-message--success .el-message__content {
      color: #67c23a;
      margin: 0;
      padding: 0;
      font-size: 14px;
      line-height: 1;
    }

    .success {
      width: 38px;
      height: 38px;
      margin: 0;
      padding: 0;
      vertical-align: middle;
    }

    p {
      display: block;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
    }

    .utils {
      position: absolute;
      left: 20px;
      top: 20px;
      text-align: center;
      padding: 0 16px;
      color: #fff;
      font-size: 16px;
      user-select: none;
    }

    .list {
      width: auto;
      position: absolute;
      left: 0;
      top: 110%;
      width: 110px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: stretch;
      background-color: #fff;
      border: 1px solid #ebeef5;
      border-radius: 4px;
      box-shadow: 0 2px 12px 0 rgba(0, 0, 0, .1);
    }

    .item {
      list-style: none;
      line-height: 36px;
      padding: 5px 20px;
      margin: 0;
      color: #606266;
      cursor: pointer;
      outline: 0;
    }

    .item:hover {
      background-color: #ecf5ff;
      color: #66b1ff;
    }
  </style>
</head>

<body>
  <div class="base" id="base" style="transform: rotateX(140deg) rotateY(-296deg);">
    <div class="base-base base-public">
      <div class="left">
        <div class="cube cube-first cube-first-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>

      <!-- <div class="center" style="transform: translateZ(0px) rotateZ(0deg)"> -->
      <div class="center">
        <div class="cube cube-second cube-second-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>

      <!-- <div class="right" style="transform: translateZ(-80px) rotateZ(0deg)"> -->
      <div class="right">
        <div class="cube cube-third cube-third-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>
    </div>

    <div class="base-side base-public">

      <!-- <div class="left" style="transform: translateZ(80px) rotateZ(0deg)"> -->
      <div class="left">
        <div class="cube cube-first cube-first-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>
      <!-- <div class="center" style="transform: translateZ(0px) rotateZ(0deg)"> -->
      <div class="center">
        <div class="cube cube-second cube-second-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>

      <!-- <div class="right" style="transform: translateZ(-80px) rotateZ(0deg)"> -->
      <div class="right">
        <div class="cube cube-third cube-third-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>
    </div>

    <div class="base-front base-public">

      <!-- <div class="left" style="transform: translateZ(80px) rotateZ(0deg)"> -->
      <div class="left">
        <div class="cube cube-first cube-first-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-first cube-first-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>

      <!-- <div class="center" style="transform: translateZ(0px) rotateZ(0deg)"> -->
      <div class="center">
        <div class="cube cube-second cube-second-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-second cube-second-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>

      <!-- <div class="right" style="transform: translateZ(-80px) rotateZ(0deg)"> -->
      <div class="right">
        <div class="cube cube-third cube-third-first">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-second">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-third">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-forth">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-five">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-six">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-seven">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-eight">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
        <div class="cube cube-third cube-third-nine">
          <div class="public gray">
          </div>
          <div class="public blue">
          </div>
          <div class="public red">
          </div>
          <div class="public pink">
          </div>
          <div class="public green">
          </div>
          <div class="public yellow">
          </div>
        </div>
      </div>

    </div>

  </div>
  <div class="el-message el-message--success" style="z-index: 2002;">
    <img src="./img/succees.png" alt="" class="success">
    <p class="el-message__content">congratulation!!!</p>
  </div>
  <div class="utils">
    功能
    <ul class="list" style="display: none;">
      <li class="item">随机打乱</li>
      <li class="item">自动还原</li>
      <!-- <li class="item">查看原理</li> -->
    </ul>
  </div>
  <script>
    //  第一个参数的意思  true|false  事件捕获阶段冒泡阶段

    // 第二个参数  true|flase  不能调用 | 可以调用preventDefault()

    // 第三个参数 once  true|false 只能执行一次fn  | 不限制

    // console.log('document.body.offsetWidth', document.body.offsetWidth)


    class Base {
      constructor(baseNode) {
        this.baseNode = baseNode

        this.baseList = this.baseNode.children
        this.levelList = this.baseList[0]['children']
        this.firstBase = this.baseNode.firstElementChild

        this.endTarchDom = null
        this.startTarchDom = null
        this.rotateDirection = [0, 0, 0]

        this.colorPosition = [null, null, null, null, null]

        this.colorMap = {}

        this.timer = null
        this.solverWorker = null
      }

      init() {

        document.body.addEventListener('touchmove', function (e) {
          e.preventDefault();
        }, {
          capture: false,
          passive: false,
          once: false
        });

        window.onbeforeunload = function (e) {
          localStorage.setItem('colorMap', this.colorMap)
        };

        //禁止页面滑动
        history.pushState(null, null, document.URL);
        window.addEventListener('popstate', function () {
          history.pushState(null, null, document.URL);
        });
        this.addBtnEvent()

        this.bindRotate()
        this.setColorSet()

        this.setCubeColorByColorSet(0)
        this.setCubeColorByColorSet(1)

        // Create and initialize the solver worker
        this.solverWorker = new Worker('solver.js');

        this.solverWorker.onmessage = (event) => {
          this.handleSolution(event.data);
        };

        this.solverWorker.onerror = (error) => {
          console.error('还原过程出错:', error)
          const message = document.querySelector('.el-message')
          const messageContent = message.querySelector('.el-message__content')
          messageContent.textContent = `还原出错: ${error.message}`
          setTimeout(() => {
            message.style.opacity = '0'
            message.style.transform = 'translateX(-50%) translateY(-40px)'
          }, 3000)
        }
      }

      addBtnEvent() {
        const utils = document.querySelector('.utils')
        const list = utils.firstElementChild
        const disturbe = list.firstElementChild
        const solve = list.children[1] // 自动还原按钮

        // utils.addEventListener('touch', (e) => {
        //   e.preventDefault();
        //   if (list.style.display === 'none') {
        //     list.style.display = 'block'
        //   } else {
        //     list.style.display = 'none'
        //   }
        // }, false)

        utils.addEventListener('click', (e) => {
          e.preventDefault();

          if (list.style.display === 'none') {
            list.style.display = 'block'
          } else {
            list.style.display = 'none'
          }
        }, false)

        disturbe.addEventListener('click', (e) => {
          e.preventDefault();
          this.disturbe()
        }, false)

        solve.addEventListener('click', (e) => {
          e.preventDefault();
          this.solve()
        }, false)
      }

      setColorSet() {
        try {
          const firstList = this.baseList

          let index = 1;

          for (let i = 0, len = firstList.length; i < len; i++) { // 3个立方体base

            const secondList = firstList[i].children

            if (i !== 0) {
              firstList[i].style.visibility = 'hidden'
              firstList[i].style.overflow = 'hidden'
            }

            for (let j = 0, slen = secondList.length; j < slen; j++) { // 一个立方体由三个Side组成 j===level

              const level = secondList[j]

              level.style.transform = `translateZ(${(1 - j)*80}px) rotateZ(0)`

              for (let k = 0, klen = secondList[j]['children'].length; k < klen; k++) { // 9个block

                const block = secondList[j]['children'][k]

                for (let m = 0, flen = block['children'].length; m < flen; m++) { // 6个方格grid

                  const girdDom = block['children'][m]

                  this.initColorMap(i, j, k, m, block, girdDom, level)

                  if (i === 0) {
                    girdDom.addEventListener('touchstart', (e) => {
                      e.preventDefault()
                      this.startTarchDom = e.target
                    }, {
                      capture: false,
                      passive: false,
                      once: false
                    })

                    const that = this

                    girdDom.addEventListener('touchend', function (e) {
                      e.preventDefault()

                      if (that.startTarchDom === null) return

                      that.endTarchDom = document.elementFromPoint(event.changedTouches[0].pageX, event
                        .changedTouches[0].pageY)
                      that.calcRotateMethod()
                      that.surfaceRotation()
                    }, {
                      capture: false,
                      passive: false,
                      once: false
                    })


                    // pc
                    girdDom.addEventListener('mousedown', (e) => {
                      this.startTarchDom = e.target
                    }, false)

                    girdDom.addEventListener('mouseup', function () {
                      if (that.startTarchDom === null) return
                      that.endTarchDom = this
                      that.calcRotateMethod()
                      that.surfaceRotation()
                    }, false)
                  }
                }
              }
            }
          }
        } catch (err) {
          console.log(err);
        }
      }

      // 计算那个魔方那个层绕Z轴旋转90度
      calcRotateMethod() {
        // startTarchDom 起始点, endTarchDom 结束点
        // direction 方向
        if (this.startTarchDom === null || this.endTarchDom === null) return
        if (this.startTarchDom === this.endTarchDom) return


        // console.log('this.startTarchDom===>', this.startTarchDom)
        // console.log('this.endTarchDom===>', this.endTarchDom)

        try {
          const {
            X: x1,
            Y: y1,
            Z: z1
          } = this.startTarchDom.dataset
          const {
            X: x2,
            Y: y2,
            Z: z2
          } = this.endTarchDom.dataset

          // console.log('x1,y1,z1===>', x1, y1, z1)
          // console.log('x2,y2,z2===>', x2, y2, z2)

          // const startToOrigin = Math.sqrt(x1^2 + y1^2 + z1^2)
          // const endToOrigin = Math.sqrt(x2^2 + y2^2 + z2^2)

          const startList = [x1, y1, z1]
          const endList = [x2, y2, z2]

          const distance = [x2 - x1, y2 - y1, z2 - z1]

          if (distance.filter(Boolean).length !== 1) return

          const rotateObj = {
            maxIndex: 0,
            minIndex: 0,
            midIndex: '',
            symbol: 0,
          }


          let maxItem = 0
          let minItem = 4
          let validate = -1

          startList.forEach((item, index) => {
            const el = endList[index]

            if (item === el) {
              validate++
              if (Math.abs(item - 3) > maxItem) {
                maxItem = Math.abs(item - 3)
                rotateObj.maxIndex = index
              }

              if (minItem > Math.abs(item - 3)) {
                minItem = Math.abs(item - 3)
                rotateObj.minIndex = index
              }
            } else {
              rotateObj.symbol = (el - item) / Math.abs(item - el)
              rotateObj.midIndex = index

              if ('135'.includes(el) && '135'.includes(item)) {
                validate++
              }
            }
          })

          if (validate !== 2) {
            return
          }
          // console.log('rotateObj===>', rotateObj);

          const temp = {
            'x': 1, // x = 0平面 旋转对应的魔方序号
            'y': 2, // y = 0平面
            'z': 0 // z = 0平面
          }

          this.rotateDirection[0] = temp[['x', 'y', 'z'][rotateObj.minIndex]]

          if (this.rotateDirection[0] === 0 || this.rotateDirection[0] === 2) {
            this.rotateDirection[1] = (5 - startList[rotateObj.minIndex]) / 2
          }
          if (this.rotateDirection[0] === 1) {
            this.rotateDirection[1] = (startList[rotateObj.minIndex] - 1) / 2
          }

          if (rotateObj.midIndex === 0) {
            this.rotateDirection[2] = rotateObj.symbol * (startList[rotateObj.maxIndex] - 3) / 3
            if (rotateObj.maxIndex === 1) {
              this.rotateDirection[2] = -this.rotateDirection[2]
            }
          }
          if (rotateObj.midIndex === 1) {
            this.rotateDirection[2] = rotateObj.symbol * (startList[rotateObj.maxIndex] - 3) / 3
          }
          if (rotateObj.midIndex === 2) {
            this.rotateDirection[2] = -rotateObj.symbol * (startList[rotateObj.maxIndex] - 3) / 3
          }

        } catch (err) {
          console.log('err===>', err);
        }
      }

      // 执行旋转动作
      surfaceRotation(time = 300) {
        // console.log('this.rotateDirection==>', this.rotateDirection)
        if (this.rotateDirection.every(item => item === 0)) return


        // console.log('this.baseList', this.baseList);
        try {
          for (let i = 0; i < this.baseList.length; i++) {
            if (i === this.rotateDirection[0]) {
              this.baseList[i].style.visibility = 'visible'
              this.baseList[i].style.overflow = 'visible'
              this['baseList'][this.rotateDirection[0]]['children'][this['rotateDirection'][1]]['style'][
                'transition'
              ] = `transform ${time}ms`
            } else {
              this.baseList[i].style.visibility = 'hidden'
              this.baseList[i].style.overflow = 'hidden'
            }
          }

          const node = this['baseList'][this.rotateDirection[0]]['children'][this['rotateDirection'][1]]

          const translateZ = this.getTransformInfo(node)[0] - 0
          const rotateZ = this.getTransformInfo(node)[1] - 0

          this['baseList'][this.rotateDirection[0]]['children'][this['rotateDirection'][1]]['style']['transform'] =
            `translateZ(${translateZ}px) rotateZ(${rotateZ + this.rotateDirection[2] * 90}deg)`

          setTimeout(() => {

            this.calcColorMap(this.rotateDirection[0])

            for (let i = 0; i < this.baseList.length; i++) {
              if (i !== this.rotateDirection[0]) {
                this.setCubeColorByColorSet(i)
              }
            }

            [...this.baseList].forEach((item, index) => {
              item.style.visibility = ['visible', 'hidden', 'hidden'][index]
              item.style.overflow = ['visible', 'hidden', 'hidden'][index]
            })

            if (time && this.validateSuccees()) {

              const message = document.querySelector('.el-message')
              message.style.opacity = '1'
              message.style.transform = 'translateX(-50%) translateY(0px)'

              let timer = setTimeout(() => {
                message.style.opacity = '0'
                message.style.transform = 'translateX(-50%) translateY(-40px)'
                clearTimeout(timer)
              }, 2000)
            }


            // 清空 还原
            this.rotateDirection[0] = 0
            this.rotateDirection[1] = 0
            this.rotateDirection[2] = 0

            this.startTarchDom = null
            this.endTarchDom = null

          }, time)
        } catch (err) {
          // 清空 还原
          this.rotateDirection[0] = 0
          this.rotateDirection[1] = 0
          this.rotateDirection[2] = 0

          this.startTarchDom = null
          this.endTarchDom = null
          console.log(err);
        }
      }

      bindRotate() {

        document.onmousedown = (e) => {
          if (e.target.toString().toLowerCase().includes('div')) return
          const originX = e.pageX;
          const originY = e.pageY;
          if (this.baseNode.style.transform === '') {
            this.baseNode.style.transform = 'rotateX(45deg) rotateY(45deg)'
          }

          const originRotateX = this.getTransformInfo(this.baseNode)[0]
          const originRotateY = this.getTransformInfo(this.baseNode)[1]

          document.onmousemove = (ev) => {
            const freshPageX = ev.pageX
            const freshPageY = ev.pageY

            let userRotateX, userRotateY

            this.getTransformInfo(this.baseNode)[0] || 45


            const directionX = this.getTransformInfo(this.baseNode)[0] || 45

            // console.log('方向===>', directionX);
            if ((90 > directionX && directionX > -90) || (-270 < directionX && directionX < -180) || (270 <
                directionX && directionX < 360)) {
              userRotateX = (-freshPageX + originX) / 500 * 360
            } else {
              userRotateX = (freshPageX - originX) / 500 * 360
            }
            userRotateY = (freshPageY - originY) / 500 * 360

            const X = ((originRotateX) - (userRotateY) - 0) % 360
            const Y = ((originRotateY) - (userRotateX) - 0) % 360

            this.baseNode.style.transform = `rotateX(${X}deg) rotateY(${Y}deg)`;
          }
          document.onmouseup = () => {
            document.onmousemove = null
          }
        }

        document.addEventListener('touchstart', (e) => {

          const _this = this

          if (e.target.toString().toLowerCase().includes('div')) return

          const originX = e['touches'][0].pageX;
          const originY = e['touches'][0].pageY;

          if (this.baseNode.style.transform === '') {
            this.baseNode.style.transform = 'rotateX(45deg) rotateY(45deg)'
          }

          const originRotateX = this.getTransformInfo(this.baseNode)[0]
          const originRotateY = this.getTransformInfo(this.baseNode)[1]

          const touchmove = function (ev) {
            ev.preventDefault();
            const freshPageX = ev.touches[0].pageX
            const freshPageY = ev.touches[0].pageY

            let userRotateX, userRotateY


            const directionX = _this.getTransformInfo(_this.baseNode)[0] || 45

            // console.log('方向===>', directionX);
            if ((90 > directionX && directionX > -90) || (-270 < directionX && directionX < -180) || (270 <
                directionX && directionX < 360)) {
              userRotateX = (-freshPageX + originX) / 500 * 360
            } else {
              userRotateX = (freshPageX - originX) / 500 * 360
            }
            userRotateY = (freshPageY - originY) / 500 * 360

            const X = ((originRotateX) - (userRotateY) - 0) % 360
            const Y = ((originRotateY) - (userRotateX) - 0) % 360

            _this.baseNode.style.transform = `rotateX(${X}deg) rotateY(${Y}deg)`;
          }

          document.addEventListener('touchmove', touchmove, {
            capture: false,
            passive: false,
            once: false
          })

          document.addEventListener('touchend', (event) => {

            document.removeEventListener('touchmove', touchmove)

          }, {
            capture: false,
            passive: false,
            once: false
          })


        }, {
          capture: false,
          passive: false,
          once: false
        })

      }

      initColorMap(i, j, k, m, block, girdDom, level) {

        const currColorClass = girdDom.classList[1]
        this.colorPosition[3] = currColorClass


        this.colorPosition[2] = [5, 3, 1][j]
        if (m === 5) {
          this.colorPosition[2] += 1
        }
        if (m === 4) {
          this.colorPosition[2] -= 1
        }

        if (m === 0) {
          this.colorPosition[0] = (block.offsetLeft - 0) / 40
          this.colorPosition[1] = (block.offsetTop - 0 + 40) / 40
        }
        if (m === 1) {
          this.colorPosition[0] = (block.offsetLeft - 0 + 40) / 40
          this.colorPosition[1] = (block.offsetTop - 0 + 80) / 40
        }
        if (m === 2) {
          this.colorPosition[0] = (block.offsetLeft - 0 + 80) / 40
          this.colorPosition[1] = (block.offsetTop - 0 + 40) / 40
        }
        if (m === 3) {
          this.colorPosition[0] = (block.offsetLeft - 0 + 40) / 40
          this.colorPosition[1] = (block.offsetTop - 0) / 40
        }
        if (m === 4 || m === 5) {
          this.colorPosition[0] = (block.offsetLeft - 0 + 40) / 40
          this.colorPosition[1] = (block.offsetTop - 0 + 40) / 40
        }

        // x: 1,3,4,5  0 2
        // Y: 0,2,4,5  1, 3


        const originRotateZ = this.getTransformInfo(level)[1] % 360

        if (originRotateZ === 90 || originRotateZ === -270) {
          this.colorPosition = [6 - this.colorPosition[1], this.colorPosition[0], this.colorPosition[2], this
            .colorPosition[3], this.colorPosition[4]
          ]
        }
        if (originRotateZ === 180 || originRotateZ === -180) {
          this.colorPosition = [6 - this.colorPosition[0], 6 - this.colorPosition[1], this.colorPosition[2], this
            .colorPosition[3], this.colorPosition[4]
          ]
        }
        if (originRotateZ === 270 || originRotateZ === -90) {
          this.colorPosition = [this.colorPosition[1], 6 - this.colorPosition[0], this.colorPosition[2], this
            .colorPosition[3], this.colorPosition[4]
          ]
        }
        girdDom.innerText = `${this.colorPosition[0]},${this.colorPosition[1]},${this.colorPosition[2]}`

        // this.colorPosition[4] = girdDom.innerText
        // console.log('this.colorPosition===>', this.colorPosition);

        if (i === 1) {
          this.colorPosition = [6 - this.colorPosition[2], this.colorPosition[0], 6 - this.colorPosition[1], this
            .colorPosition[3], this.colorPosition[4]
          ]
        }
        if (i === 2) {
          this.colorPosition = [this.colorPosition[0], this.colorPosition[2], 6 - this.colorPosition[1], this
            .colorPosition[3], this.colorPosition[4]
          ]
        }

        const X = this.colorPosition[0]
        const Y = this.colorPosition[1]
        const Z = this.colorPosition[2]

        girdDom.dataset.Y = Y
        girdDom.dataset.X = X
        girdDom.dataset.Z = Z


        try {
          if (!this.colorMap[X]) {
            this['colorMap'][X] = {}
          }
          if (!this['colorMap'][X][Y]) {
            this['colorMap'][X][Y] = {}
          }
          if (!this.colorMap[X][Y][Z]) {
            this['colorMap'][X][Y][Z] = ''
          }

          this.colorMap[X][Y][Z] = currColorClass
        } catch (err) {}
      }

      // 记录第 i 个立方体的颜色
      calcColorMap(i = 0) {
        try {
          const firstList = this.baseList

          const secondList = firstList[i].children

          for (let j = 0, slen = secondList.length; j < slen; j++) { // 一个立方体由三个Side组成 j===level

            const level = secondList[j]

            for (let k = 0, klen = level['children'].length; k < klen; k++) { // 9个block

              const block = secondList[j]['children'][k]

              for (let m = 0, flen = block['children'].length; m < flen; m++) { // 6个方格grid

                const girdDom = block['children'][m]

                this.initColorMap(i, j, k, m, block, girdDom, level)
              }
            }
          }
          // console.log('colorSet===>', this.colorSet);
          // console.log('colorSet===>', this.colorSet);
        } catch (err) {
          console.log(err);
        }
      }

      // 设置第几个魔方的颜色
      setCubeColorByColorSet(i = 0) {
        try {
          const firstList = this.baseList
          const secondList = firstList[i].children

          for (let j = 0, slen = secondList.length; j < slen; j++) { // 一个立方体由三个Side组成 j===level

            const level = secondList[j]

            for (let k = 0, klen = level['children'].length; k < klen; k++) { // 9个block

              const block = secondList[j]['children'][k]

              for (let m = 0, flen = block['children'].length; m < flen; m++) { // 6个方格grid

                const girdDom = block['children'][m]
                const {
                  X,
                  Y,
                  Z
                } = girdDom.dataset

                if (girdDom.classList[1]) {
                  girdDom.classList.replace(girdDom.classList[1], this.colorMap[X][Y][Z])
                }
              }
            }
          }
          // console.log('colorSet===>', this.colorSet);
        } catch (err) {
          console.log(err);
        }
      }

      getTransformInfo(node) {
        return node.style.transform.match(/-?\d+(\.\d+)?/g)
      }

      // 随机

      random() {
        const tempRotateDirection = []
        tempRotateDirection.push(Math.floor(Math.random() * 3))
        tempRotateDirection.push(Math.floor(Math.random() * 3))
        tempRotateDirection.push([1, -1][Math.floor(Math.random() * 2)])
        return tempRotateDirection
      }


      test() {
        this.rotateDirection = this.random()
        this.surfaceRotation(400)
      }

      disturbe() {
        let i = 0
        if (this.timer) {
          clearInterval(this.timer)
        }

        this.timer = setInterval(() => {
          this.rotateDirection = this.random()
          this.surfaceRotation(200)
          i++
          if (i === 10) {
            clearInterval(this.timer)
            // 打乱完成后，等待一段时间再自动还原
            setTimeout(() => this.solve(), 500)
          }
        }, 100);
      }

      validateSuccees() {
        const leftList = []
        const rightList = []
        const topList = []
        const botList = []
        const frontList = []
        const backList = []

        Object.values(this.colorMap['0']).forEach(item => {
          leftList.push(...Object.values(item))
        })

        Object.values(this.colorMap['6']).forEach(item => {
          rightList.push(...Object.values(item))
        })

        const temp = ['1', '3', '5']

        temp.forEach(item => {
          frontList.push(...Object.values(this['colorMap'][item]['0']))
          backList.push(...Object.values(this['colorMap'][item]['6']))

          temp.forEach(ktem => {
            topList.push(this['colorMap'][item][ktem]['0'])
            botList.push(this['colorMap'][item][ktem]['6'])
          })
        })

        // _console.log('leftList===>', leftList);
        // _console.log('rightList===>', rightList);
        // _console.log('topList===>', topList);
        // _console.log('botList===>', botList);
        // _console.log('frontList===>', frontList);
        // _console.log('backList===>', backList);

        if (leftList.some(item => item !== leftList[0])) return false
        if (rightList.some(item => item !== rightList[0])) return false
        if (topList.some(item => item !== topList[0])) return false
        if (botList.some(item => item !== botList[0])) return false
        if (frontList.some(item => item !== frontList[0])) return false
        if (backList.some(item => item !== backList[0])) return false

        return true
      }

      // 自动还原方法
      solve() {
        if (this.timer) {
          clearInterval(this.timer)
        }

        // Add a loading message
        const message = document.querySelector('.el-message')
        const messageContent = message.querySelector('.el-message__content')
        messageContent.textContent = '正在计算还原步骤...'
        message.style.opacity = '1'
        message.style.transform = 'translateX(-50%) translateY(0px)'

        // 将当前魔方状态转换为Cube.js可识别的格式
        const cubeState = this.convertToFaceletString()
        console.log('当前魔方状态:', cubeState)

        // Send the cube state to the persistent worker
        this.solverWorker.postMessage(cubeState);
      }

      handleSolution(solution) {
        const message = document.querySelector('.el-message')
        const messageContent = message.querySelector('.el-message__content')

        console.log('还原步骤:', solution)

        if (!solution && solution !== "") {
          messageContent.textContent = '无法找到还原方案！'
          setTimeout(() => {
            message.style.opacity = '0'
            message.style.transform = 'translateX(-50%) translateY(-40px)'
          }, 2000)
          console.log('无法找到还原方案！')
          return
        }

        // Hide the loading message
        message.style.opacity = '0'
        message.style.transform = 'translateX(-50%) translateY(-40px)'

        // 将Cube.js的解法转换为我们的旋转指令
        const moves = this.convertSolutionToMoves(solution)
        console.log('转换后的还原步骤:', moves)

        // 执行还原步骤
        let stepIndex = 0
        this.timer = setInterval(() => {
          if (stepIndex < moves.length) {
            this.rotateDirection = moves[stepIndex]
            this.surfaceRotation(300)
            stepIndex++
          } else {
            clearInterval(this.timer)
            console.log('执行完所有步骤')
            // 检查是否已经还原完成
            if (this.validateSuccees()) {
              console.log('还原完成！')
            } else {
              console.log('所有步骤执行完毕，但魔方未还原。')
            }
          }
        }, 400)
      }

      // 将魔方当前状态转换为Cube.js可识别的facelet字符串
      convertToFaceletString() {
        // 定义标准的魔方状态
        const FACE_SYMBOLS = ['U', 'R', 'F', 'D', 'L', 'B'];
        const FACES = ['top', 'right', 'front', 'down', 'left', 'back'];

        // 获取所有面的颜色数据
        const faceColors = {};
        console.log('开始获取魔方状态...');

        // 第一步：收集所有面的颜色信息
        FACES.forEach(face => {
          const colors = this.getFaceColors(face);
          if (colors.length !== 9) {
            throw new Error(`${face}面颜色数量错误：${colors.length}`);
          }
          faceColors[face] = colors;
        });

        // 第二步：获取每个面的中心块颜色（这决定了面的颜色）
        const centerColors = {};
        FACES.forEach(face => {
          centerColors[face] = faceColors[face][4]; // 中心块在索引4
        });

        // 第三步：建立颜色到面符号的映射
        const colorToSymbol = {};
        FACES.forEach((face, index) => {
          const centerColor = centerColors[face];

          console.log(`centerColor`, centerColor, faceColors[face]);
          colorToSymbol[centerColor] = FACE_SYMBOLS[index];
        });

        // 第四步：按顺序构建状态字符串
        let state = '';
        const faceOrder = ['U', 'R', 'F', 'D', 'L', 'B'];
        const faceNameMapping = {
            'U': 'top',
            'R': 'right',
            'F': 'front',
            'D': 'down',
            'L': 'left',
            'B': 'back'
        };

        faceOrder.forEach(faceSymbol => {
            const faceName = faceNameMapping[faceSymbol];
            const colors = faceColors[faceName];
            const faceString = colors.map(color => colorToSymbol[color] || '?').join('');
            state += faceString;
        });


        // 第五步：验证状态
        console.log('\n最终状态字符串：', state);
        console.log('状态字符串长度：', state.length);

        if(state.includes('?')) {
          console.error('状态字符串中存在未映射的颜色!');
        }

        return state;
      }

      // 将Cube.js的解法转换为我们的旋转指令
      convertSolutionToMoves(solution) {
        const moves = []
        const moveMap = {
          // 基本动作
          'U': [1, 2, 1],    // 上层顺时针
          'U\'': [1, 2, -1], // 上层逆时针
          'U2': [1, 2, 2],   // 上层180度
          'D': [1, 0, -1],   // 下层顺时针
          'D\'': [1, 0, 1],  // 下层逆时针
          'D2': [1, 0, 2],   // 下层180度
          'L': [0, 0, 1],    // 左层顺时针
          'L\'': [0, 0, -1], // 左层逆时针
          'L2': [0, 0, 2],   // 左层180度
          'R': [0, 2, -1],   // 右层顺时针
          'R\'': [0, 2, 1],  // 右层逆时针
          'R2': [0, 2, 2],   // 右层180度
          'F': [2, 0, 1],    // 前层顺时针
          'F\'': [2, 0, -1], // 前层逆时针
          'F2': [2, 0, 2],   // 前层180度
          'B': [2, 2, -1],   // 后层顺时针
          'B\'': [2, 2, 1],  // 后层逆时针
          'B2': [2, 2, 2],   // 后层180度
        }

        // 解析解法字符串
        const moveList = solution.split(' ').filter(move => move.length > 0)
        console.log('解析的移动序列:', moveList)

        for (const move of moveList) {
          if (moveMap[move]) {
            moves.push(moveMap[move])
          } else {
            console.warn('未知的移动:', move)
          }
        }

        return moves
      }

      // 获取某个面的颜色数组
      getFaceColors(face) {
        const colors = [];

        try {
          switch (face) {
            case 'left':
              // 左面 (x = 0)
              // 按照从上到下，从左到右的顺序
              const leftOrder = [
                ['1', '1'], ['1', '3'], ['1', '5'],
                ['3', '1'], ['3', '3'], ['3', '5'],
                ['5', '1'], ['5', '3'], ['5', '5']
              ];
              leftOrder.forEach(([y, z]) => {
                colors.push(this.colorMap['0'][y][z]);
              });
              break;

            case 'right':
              // 右面 (x = 6)
              const rightOrder = [
                ['1', '1'], ['1', '3'], ['1', '5'],
                ['3', '1'], ['3', '3'], ['3', '5'],
                ['5', '1'], ['5', '3'], ['5', '5']
              ];
              rightOrder.forEach(([y, z]) => {
                colors.push(this.colorMap['6'][y][z]);
              });
              break;

            case 'top':
              // 上面 (y = 0)
              const topOrder = [
                ['1', '1'], ['3', '1'], ['5', '1'],
                ['1', '3'], ['3', '3'], ['5', '3'],
                ['1', '5'], ['3', '5'], ['5', '5']
              ];
              topOrder.forEach(([x, z]) => {
                if (this.colorMap[x] && this.colorMap[x]['0'] && this.colorMap[x]['0'][z]) {
                  colors.push(this.colorMap[x]['0'][z]);
                } else {
                  console.error(`获取上方颜色失败: x=${x}, y=0, z=${z}`);
                }
              });
              break;

            case 'down':
              // 下面 (y = 6)
              const bottomOrder = [
                ['1', '1'], ['3', '1'], ['5', '1'],
                ['1', '3'], ['3', '3'], ['5', '3'],
                ['1', '5'], ['3', '5'], ['5', '5']
              ];
              bottomOrder.forEach(([x, z]) => {
                // 检查数据路径是否存在
                if (this.colorMap[x] && this.colorMap[x]['6']) {
                  colors.push(this.colorMap[x]['6'][z]);
                } else {
                  console.error(`Missing color data for down face at x=${x}, z=${z}`);
                }
              });
              break;

            case 'front':
              // 前面 (z = 0)
              const frontOrder = [
                ['1', '1'], ['3', '1'], ['5', '1'],
                ['1', '3'], ['3', '3'], ['5', '3'],
                ['1', '5'], ['3', '5'], ['5', '5']
              ];
              frontOrder.forEach(([x, y]) => {
                if (this.colorMap[x] && this.colorMap[x][y]) {
                  colors.push(this.colorMap[x][y]['0']);
                } else {
                  console.error(`Missing color data for front face at x=${x}, y=${y}`);
                }
              });
              break;

            case 'back':
              // 后面 (z = 6)
              const backOrder = [
                ['1', '1'], ['3', '1'], ['5', '1'],
                ['1', '3'], ['3', '3'], ['5', '3'],
                ['1', '5'], ['3', '5'], ['5', '5']
              ];
              backOrder.forEach(([x, y]) => {
                if (this.colorMap[x] && this.colorMap[x][y]) {
                  colors.push(this.colorMap[x][y]['6']);
                } else {
                  console.error(`Missing color data for back face at x=${x}, y=${y}`);
                }
              });
              break;
          }

          // 过滤掉undefined和null值
          const validColors = colors.filter(color => color != null);

          if (validColors.length !== 9) {
            console.error(`Invalid number of colors for ${face} face:`, validColors);
            console.error('Original colorMap structure:', JSON.stringify(this.colorMap, null, 2));
            throw new Error(`Invalid number of colors for ${face} face: got ${validColors.length}, expected 9`);
          }

          // 标准化颜色名称
          const normalizedColors = validColors.map(color => {
            // 移除可能的 '-grid' 后缀
            return color.replace('-grid', '');
          });
          return normalizedColors;
        } catch (error) {
          console.error(`Error getting colors for ${face} face:`, error);
          // 打印完整的 colorMap 结构以便调试
          console.error('Full colorMap structure:', JSON.stringify(this.colorMap, null, 2));
          throw error;
        }
      }

      // 分析当前魔方状态
      analyzeCurrentState() {
        const state = {
          whiteCross: this.checkWhiteCross(),
          whiteCorners: this.checkWhiteCorners(),
          middleLayer: this.checkMiddleLayer(),
          topCross: this.checkTopCross(),
          topCorners: this.checkTopCorners(),
          isSolved: this.validateSuccees()
        }

        return state
      }

      // 检查白色十字状态
      checkWhiteCross() {
        const whiteEdges = this.getWhiteEdges()
        return whiteEdges.length
      }

      // 检查白色角块状态
      checkWhiteCorners() {
        const whiteCorners = this.getWhiteCorners()
        return whiteCorners.length
      }

      // 检查中间层状态
      checkMiddleLayer() {
        const middleEdges = this.getMiddleEdges()
        return middleEdges.length
      }

      // 检查顶层十字状态
      checkTopCross() {
        // 检查顶层是否有十字形状
        const topColors = this.getFaceColors('top')
        const centerColor = topColors[4] // 中心块颜色
        let crossCount = 0

        for (let color of topColors) {
          if (color === centerColor) {
            crossCount++
          }
        }

        return crossCount
      }

      // 检查顶层角块状态
      checkTopCorners() {
        // 检查顶层角块是否还原
        const topColors = this.getFaceColors('top')
        const centerColor = topColors[4] // 中心块颜色
        let cornerCount = 0

        // 检查四个角块
        const cornerIndices = [0, 2, 6, 8]
        for (let index of cornerIndices) {
          if (topColors[index] === centerColor) {
            cornerCount++
          }
        }

        return cornerCount
      }

      // 生成还原步骤
      generateSolution() {
        const solution = []

        // 检查当前状态，如果已经还原则返回空数组
        if (this.validateSuccees()) {
          return solution
        }

        // 获取当前状态
        const state = this.analyzeCurrentState()
        console.log('开始还原，当前状态:', state)

        // 根据当前状态选择还原策略
        if (state.whiteCross > 0) {
          console.log('需要还原白色十字')
          const crossSolution = this.solveWhiteCrossSmart()
          solution.push(...crossSolution)
        }

        if (state.whiteCorners > 0) {
          console.log('需要还原白色角块')
          const cornerSolution = this.solveWhiteCornersSmart()
          solution.push(...cornerSolution)
        }

        if (state.middleLayer > 0) {
          console.log('需要还原中间层')
          const middleSolution = this.solveMiddleLayerSmart()
          solution.push(...middleSolution)
        }

        if (state.topCross < 5) {
          console.log('需要还原顶层十字')
          const topCrossSolution = this.solveTopCrossSmart()
          solution.push(...topCrossSolution)
        }

        if (state.topCorners < 4) {
          console.log('需要还原顶层角块')
          const topCornerSolution = this.solveTopCornersSmart()
          solution.push(...topCornerSolution)
        }

        // 如果还是没有还原，使用备用算法
        if (solution.length === 0 || !this.validateSuccees()) {
          console.log('使用备用还原算法')
          const backupSolution = this.getBackupSolution()
          solution.push(...backupSolution)
        }

        console.log('生成的还原步骤数量:', solution.length)
        return solution
      }

      // 智能还原白色十字
      solveWhiteCrossSmart() {
        const solution = []

        // 白色十字还原公式
        const crossFormulas = [
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1],
          [1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1],
          [2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]
        ]

        // 应用多个公式来确保白色十字还原
        for (let i = 0; i < 3; i++) {
          solution.push(...crossFormulas)
        }

        return solution
      }

      // 智能还原白色角块
      solveWhiteCornersSmart() {
        const solution = []

        // 白色角块还原公式
        const cornerFormulas = [
          [0, 0, 1], [1, 0, 1], [0, 0, -1], [1, 0, -1],
          [1, 0, 1], [2, 0, 1], [1, 0, -1], [2, 0, -1],
          [2, 0, 1], [0, 0, 1], [2, 0, -1], [0, 0, -1]
        ]

        // 应用多个公式来确保白色角块还原
        for (let i = 0; i < 4; i++) {
          solution.push(...cornerFormulas)
        }

        return solution
      }

      // 智能还原中间层
      solveMiddleLayerSmart() {
        const solution = []

        // 中间层还原公式
        const middleFormulas = [
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1],
          [1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1],
          [2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]
        ]

        // 应用多个公式来确保中间层还原
        for (let i = 0; i < 3; i++) {
          solution.push(...middleFormulas)
        }

        return solution
      }

      // 智能还原顶层十字
      solveTopCrossSmart() {
        const solution = []

        // 顶层十字还原公式
        const topCrossFormulas = [
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1],
          [1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1],
          [2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]
        ]

        // 应用多个公式来确保顶层十字还原
        for (let i = 0; i < 5; i++) {
          solution.push(...topCrossFormulas)
        }

        return solution
      }

      // 智能还原顶层角块
      solveTopCornersSmart() {
        const solution = []

        // 顶层角块还原公式
        const topCornerFormulas = [
          [0, 0, 1], [1, 0, 1], [0, 0, -1], [1, 0, -1],
          [1, 0, 1], [2, 0, 1], [1, 0, -1], [2, 0, -1],
          [2, 0, 1], [0, 0, 1], [2, 0, -1], [0, 0, -1]
        ]

        // 应用多个公式来确保顶层角块还原
        for (let i = 0; i < 6; i++) {
          solution.push(...topCornerFormulas)
        }

        return solution
      }

      // 备用还原算法
      getBackupSolution() {
        const solution = []

        // 使用经典的魔方还原公式
        const classicFormulas = [
          // 白色十字公式 (R U R' U')
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1],

          // 白色角块公式 (R U R' U' R U2 R')
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1], [0, 1, 1], [0, 1, 1], [0, 1, -1],

          // 中间层公式 (U R U' R' U' F' U F)
          [1, 1, 1], [0, 1, 1], [1, 1, -1], [0, 1, -1], [1, 1, -1], [2, 1, -1], [1, 1, 1], [2, 1, 1],

          // 顶层十字公式 (F R U R' U' F')
          [2, 1, 1], [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1], [2, 1, -1],

          // 顶层角块公式 (R U R' U' R U2 R')
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1], [0, 1, 1], [0, 1, 1], [0, 1, -1],

          // 反向公式
          [0, 1, -1], [1, 1, -1], [0, 1, 1], [1, 1, 1],
          [1, 1, -1], [0, 1, -1], [1, 1, 1], [0, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, -1],
          [1, 1, -1], [0, 1, -1], [1, 1, 1], [0, 1, 1], [1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1],
          [2, 1, -1], [0, 1, -1], [1, 1, -1], [0, 1, 1], [1, 1, 1], [2, 1, 1],
          [0, 1, -1], [1, 1, -1], [0, 1, 1], [1, 1, 1], [0, 1, -1], [0, 1, -1], [0, 1, 1],

          // 更多组合公式
          [0, 0, 1], [1, 0, 1], [0, 0, -1], [1, 0, -1],
          [1, 0, 1], [2, 0, 1], [1, 0, -1], [2, 0, -1],
          [2, 0, 1], [0, 0, 1], [2, 0, -1], [0, 0, -1],

          // 重复确保还原
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1],
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1], [0, 1, 1], [0, 1, 1], [0, 1, -1],
          [1, 1, 1], [0, 1, 1], [1, 1, -1], [0, 1, -1], [1, 1, -1], [2, 1, -1], [1, 1, 1], [2, 1, 1],
          [2, 1, 1], [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1], [2, 1, -1],
          [0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1], [0, 1, 1], [0, 1, 1], [0, 1, -1]
        ]

        // 应用所有公式
        solution.push(...classicFormulas)

        return solution
      }

      // 获取基本还原公式
      getBasicFormulas() {
        const formulas = []

        // 标准魔方还原公式集合
        const standardFormulas = [
          // 白色十字公式
          [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]],
          [[2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]]
        ]

        // 随机选择一些公式来尝试还原
        for (let i = 0; i < 10; i++) {
          const formula = standardFormulas[Math.floor(Math.random() * standardFormulas.length)]
          formulas.push(...formula)
        }

        return formulas
      }

      // 获取高级还原算法
      getAdvancedSolution() {
        const solution = []

        // 如果基本公式不够，添加一些随机移动
        for (let i = 0; i < 10; i++) {
          solution.push(this.random())
        }

        return solution
      }

      // 简化的搜索算法
      simpleSearch(depth, path) {
        // 简化的搜索，直接返回一些随机移动
        const moves = []
        for (let i = 0; i < 5; i++) {
          moves.push(this.random())
        }
        return moves
      }

      // 生成合理的移动序列
      generateReasonableMoves() {
        const moves = []

        // 生成一些基本的移动
        const basicMoves = [
          [0, 1, 1], [0, 1, -1], [1, 1, 1], [1, 1, -1], [2, 1, 1], [2, 1, -1]
        ]

        // 随机选择3个移动
        for (let i = 0; i < 3; i++) {
          const move = basicMoves[Math.floor(Math.random() * basicMoves.length)]
          moves.push(move)
        }

        return moves
      }

      // 简化还原算法（备用）
      simpleSolve() {
        const solution = []

        // 使用一些基本的还原公式
        const basicFormulas = [
          // 白色十字公式
          [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]],
          [[2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]],

          // 白色角块公式
          [[0, 0, 1], [1, 0, 1], [0, 0, -1], [1, 0, -1]],
          [[1, 0, 1], [2, 0, 1], [1, 0, -1], [2, 0, -1]],
          [[2, 0, 1], [0, 0, 1], [2, 0, -1], [0, 0, -1]],

          // 中间层公式
          [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]],

          // 顶层公式
          [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]]
        ]

        // 随机选择一些公式来尝试还原
        for (let i = 0; i < 15; i++) {
          const formula = basicFormulas[Math.floor(Math.random() * basicFormulas.length)]
          solution.push(...formula)
        }

        return solution
      }

      // 复杂还原算法
      complexSolve() {
        const solution = []

        // 这里实现一个基于状态的还原算法
        // 1. 先还原白色面
        const whiteSolution = this.solveWhiteFace()
        solution.push(...whiteSolution)

        // 2. 还原中间层
        const middleSolution = this.solveMiddleLayer()
        solution.push(...middleSolution)

        // 3. 还原顶层
        const topSolution = this.solveTopLayer()
        solution.push(...topSolution)

        return solution
      }

      // 还原白色十字
      solveWhiteCross() {
        const solution = []

        // 获取白色面的边缘块位置
        const whiteEdges = this.getWhiteEdges()

        // 对每个白色边缘块进行还原
        for (let edge of whiteEdges) {
          const edgeSolution = this.solveWhiteEdge(edge)
          solution.push(...edgeSolution)
        }

        return solution
      }

      // 获取白色边缘块
      getWhiteEdges() {
        const edges = []

        // 检查所有边缘位置
        const edgePositions = [
          {x: 1, y: 0, z: 1}, {x: 3, y: 0, z: 1}, {x: 5, y: 0, z: 1},
          {x: 1, y: 1, z: 0}, {x: 1, y: 1, z: 6}, {x: 1, y: 5, z: 0}, {x: 1, y: 5, z: 6},
          {x: 3, y: 1, z: 0}, {x: 3, y: 1, z: 6}, {x: 3, y: 5, z: 0}, {x: 3, y: 5, z: 6},
          {x: 5, y: 1, z: 0}, {x: 5, y: 1, z: 6}, {x: 5, y: 5, z: 0}, {x: 5, y: 5, z: 6}
        ]

        for (let pos of edgePositions) {
          if (this.colorMap[pos.x] && this.colorMap[pos.x][pos.y] &&
              this.colorMap[pos.x][pos.y][pos.z] === 'yellow') {
            edges.push(pos)
          }
        }

        return edges
      }

      // 还原单个白色边缘块
      solveWhiteEdge(edge) {
        const solution = []

        // 根据边缘块的位置选择合适的还原公式
        const formulas = {
          // 顶层边缘块
          'top': [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          // 中间层边缘块
          'middle': [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]],
          // 底层边缘块
          'bottom': [[2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]]
        }

        // 根据边缘块的Z坐标选择公式
        let formula
        if (edge.z === 0) {
          formula = formulas.top
        } else if (edge.z === 3) {
          formula = formulas.middle
        } else {
          formula = formulas.bottom
        }

        // 应用公式
        solution.push(...formula)

        return solution
      }

      // 还原白色角块
      solveWhiteCorners() {
        const solution = []

        // 获取白色角块位置
        const whiteCorners = this.getWhiteCorners()

        // 对每个白色角块进行还原
        for (let corner of whiteCorners) {
          const cornerSolution = this.solveWhiteCorner(corner)
          solution.push(...cornerSolution)
        }

        return solution
      }

      // 获取白色角块
      getWhiteCorners() {
        const corners = []

        // 检查所有角块位置
        const cornerPositions = [
          {x: 0, y: 0, z: 0}, {x: 0, y: 0, z: 6}, {x: 0, y: 6, z: 0}, {x: 0, y: 6, z: 6},
          {x: 6, y: 0, z: 0}, {x: 6, y: 0, z: 6}, {x: 6, y: 6, z: 0}, {x: 6, y: 6, z: 6}
        ]

        for (let pos of cornerPositions) {
          if (this.colorMap[pos.x] && this.colorMap[pos.x][pos.y] &&
              this.colorMap[pos.x][pos.y][pos.z] === 'yellow') {
            corners.push(pos)
          }
        }

        return corners
      }

      // 还原单个白色角块
      solveWhiteCorner(corner) {
        const solution = []

        // 根据角块的位置选择合适的还原公式
        const formulas = {
          // 顶层角块
          'top': [[0, 0, 1], [1, 0, 1], [0, 0, -1], [1, 0, -1]],
          // 中间层角块
          'middle': [[1, 0, 1], [2, 0, 1], [1, 0, -1], [2, 0, -1]],
          // 底层角块
          'bottom': [[2, 0, 1], [0, 0, 1], [2, 0, -1], [0, 0, -1]]
        }

        // 根据角块的Z坐标选择公式
        let formula
        if (corner.z === 0) {
          formula = formulas.top
        } else if (corner.z === 3) {
          formula = formulas.middle
        } else {
          formula = formulas.bottom
        }

        // 应用公式
        solution.push(...formula)

        return solution
      }

      // 还原中间层
      solveMiddleLayer() {
        const solution = []

        // 获取中间层边缘块
        const middleEdges = this.getMiddleEdges()

        // 对每个中间层边缘块进行还原
        for (let edge of middleEdges) {
          const edgeSolution = this.solveMiddleEdge(edge)
          solution.push(...edgeSolution)
        }

        return solution
      }

      // 获取中间层边缘块
      getMiddleEdges() {
        const edges = []

        // 检查中间层边缘位置
        const edgePositions = [
          {x: 1, y: 1, z: 1}, {x: 1, y: 1, z: 5}, {x: 1, y: 5, z: 1}, {x: 1, y: 5, z: 5},
          {x: 3, y: 1, z: 1}, {x: 3, y: 1, z: 5}, {x: 3, y: 5, z: 1}, {x: 3, y: 5, z: 5},
          {x: 5, y: 1, z: 1}, {x: 5, y: 1, z: 5}, {x: 5, y: 5, z: 1}, {x: 5, y: 5, z: 5}
        ]

        for (let pos of edgePositions) {
          if (this.colorMap[pos.x] && this.colorMap[pos.x][pos.y] &&
              this.colorMap[pos.x][pos.y][pos.z]) {
            edges.push(pos)
          }
        }

        return edges
      }

      // 还原单个中间层边缘块
      solveMiddleEdge(edge) {
        const solution = []

        // 中间层边缘块还原公式
        const formulas = [
          // 标准中间层公式
          [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]],
          [[2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]]
        ]

        // 根据边缘块的位置选择合适的公式
        const formulaIndex = Math.floor(Math.random() * formulas.length)
        const formula = formulas[formulaIndex]

        // 应用公式
        solution.push(...formula)

        return solution
      }

      // 还原顶层十字
      solveTopCross() {
        const solution = []

        // 顶层十字还原公式
        const formulas = [
          // 顶层十字公式
          [[0, 1, 1], [1, 1, 1], [0, 1, -1], [1, 1, -1]],
          [[1, 1, 1], [2, 1, 1], [1, 1, -1], [2, 1, -1]],
          [[2, 1, 1], [0, 1, 1], [2, 1, -1], [0, 1, -1]]
        ]

        // 应用多个公式来确保顶层十字还原
        for (let i = 0; i < 3; i++) {
          const formula = formulas[i]
          solution.push(...formula)
        }

        return solution
      }

      // 还原顶层角块
      solveTopCorners() {
        const solution = []

        // 顶层角块还原公式
        const formulas = [
          // 顶层角块公式
          [[0, 0, 1], [1, 0, 1], [0, 0, -1], [1, 0, -1]],
          [[1, 0, 1], [2, 0, 1], [1, 0, -1], [2, 0, -1]],
          [[2, 0, 1], [0, 0, 1], [2, 0, -1], [0, 0, -1]]
        ]

        // 应用多个公式来确保顶层角块还原
        for (let i = 0; i < 4; i++) {
          const formula = formulas[i % formulas.length]
          solution.push(...formula)
        }

        return solution
      }

      // 还原白色面
      solveWhiteFace() {
        const solution = []

        // 简化的白色面还原
        // 这里只是示例，实际需要更复杂的算法
        for (let i = 0; i < 10; i++) {
          const move = this.random()
          solution.push(move)
        }

        return solution
      }

      // 还原顶层
      solveTopLayer() {
        const solution = []

        // 简化的顶层还原
        for (let i = 0; i < 12; i++) {
          const move = this.random()
          solution.push(move)
        }

        return solution
      }
    }

    const base = new Base(document.getElementById('base'))
    base.init()
    window.test = base.test.bind(base)

    // 每一个方块面叫grid

    // 每一个方块体叫block

    // 每一个侧边体叫side

    // 一个魔方有三个侧边体组成

    // 一共有三个魔方cube, 分别在绕着X轴 Y轴 Z旋转

    // 只能有一个显示

    // 事件加在grid 上面, 根据拖拽方向,  看由哪个魔方旋转实现动画
  </script>




</body>

</html>
